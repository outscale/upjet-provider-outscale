/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AccessLogObservation struct {
}

type AccessLogParameters struct {

	// +kubebuilder:validation:Optional
	IsEnabled *bool `json:"isEnabled,omitempty" tf:"is_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	OsuBucketName *string `json:"osuBucketName,omitempty" tf:"osu_bucket_name,omitempty"`

	// +kubebuilder:validation:Optional
	OsuBucketPrefix *string `json:"osuBucketPrefix,omitempty" tf:"osu_bucket_prefix,omitempty"`

	// +kubebuilder:validation:Optional
	PublicationInterval *float64 `json:"publicationInterval,omitempty" tf:"publication_interval,omitempty"`
}

type HealthCheckObservation struct {
}

type HealthCheckParameters struct {

	// +kubebuilder:validation:Required
	CheckInterval *float64 `json:"checkInterval" tf:"check_interval,omitempty"`

	// +kubebuilder:validation:Required
	HealthyThreshold *float64 `json:"healthyThreshold" tf:"healthy_threshold,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Required
	Port *float64 `json:"port" tf:"port,omitempty"`

	// +kubebuilder:validation:Required
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Required
	Timeout *float64 `json:"timeout" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Required
	UnhealthyThreshold *float64 `json:"unhealthyThreshold" tf:"unhealthy_threshold,omitempty"`
}

type LoadBalancerAttributesApplicationStickyCookiePoliciesObservation struct {
	CookieName *string `json:"cookieName,omitempty" tf:"cookie_name,omitempty"`

	PolicyName *string `json:"policyName,omitempty" tf:"policy_name,omitempty"`
}

type LoadBalancerAttributesApplicationStickyCookiePoliciesParameters struct {
}

type LoadBalancerAttributesListenersObservation struct {
	BackendPort *float64 `json:"backendPort,omitempty" tf:"backend_port,omitempty"`

	BackendProtocol *string `json:"backendProtocol,omitempty" tf:"backend_protocol,omitempty"`

	LoadBalancerPort *float64 `json:"loadBalancerPort,omitempty" tf:"load_balancer_port,omitempty"`

	LoadBalancerProtocol *string `json:"loadBalancerProtocol,omitempty" tf:"load_balancer_protocol,omitempty"`

	PolicyNames []*string `json:"policyNames,omitempty" tf:"policy_names,omitempty"`

	ServerCertificateID *string `json:"serverCertificateId,omitempty" tf:"server_certificate_id,omitempty"`
}

type LoadBalancerAttributesListenersParameters struct {
}

type LoadBalancerAttributesLoadBalancerStickyCookiePoliciesObservation struct {
	PolicyName *string `json:"policyName,omitempty" tf:"policy_name,omitempty"`
}

type LoadBalancerAttributesLoadBalancerStickyCookiePoliciesParameters struct {
}

type LoadBalancerAttributesObservation struct {
	ApplicationStickyCookiePolicies []LoadBalancerAttributesApplicationStickyCookiePoliciesObservation `json:"applicationStickyCookiePolicies,omitempty" tf:"application_sticky_cookie_policies,omitempty"`

	BackendVMIds []*string `json:"backendVmIds,omitempty" tf:"backend_vm_ids,omitempty"`

	DNSName *string `json:"dnsName,omitempty" tf:"dns_name,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Listeners []LoadBalancerAttributesListenersObservation `json:"listeners,omitempty" tf:"listeners,omitempty"`

	LoadBalancerStickyCookiePolicies []LoadBalancerAttributesLoadBalancerStickyCookiePoliciesObservation `json:"loadBalancerStickyCookiePolicies,omitempty" tf:"load_balancer_sticky_cookie_policies,omitempty"`

	LoadBalancerType *string `json:"loadBalancerType,omitempty" tf:"load_balancer_type,omitempty"`

	RequestID *string `json:"requestId,omitempty" tf:"request_id,omitempty"`

	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	SourceSecurityGroup map[string]*string `json:"sourceSecurityGroup,omitempty" tf:"source_security_group,omitempty"`

	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`

	SubregionNames []*string `json:"subregionNames,omitempty" tf:"subregion_names,omitempty"`

	// +kubebuilder:validation:Optional
	Tags []LoadBalancerAttributesTagsObservation `json:"tags,omitempty" tf:"tags,omitempty"`
}

type LoadBalancerAttributesParameters struct {

	// +kubebuilder:validation:Optional
	AccessLog []AccessLogParameters `json:"accessLog,omitempty" tf:"access_log,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheck []HealthCheckParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// +kubebuilder:validation:Required
	LoadBalancerName *string `json:"loadBalancerName" tf:"load_balancer_name,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancerPort *float64 `json:"loadBalancerPort,omitempty" tf:"load_balancer_port,omitempty"`

	// +kubebuilder:validation:Optional
	PolicyNames []*string `json:"policyNames,omitempty" tf:"policy_names,omitempty"`

	// +kubebuilder:validation:Optional
	ServerCertificateID *string `json:"serverCertificateId,omitempty" tf:"server_certificate_id,omitempty"`

	// +kubebuilder:validation:Optional
	Tags []LoadBalancerAttributesTagsParameters `json:"tags,omitempty" tf:"tags,omitempty"`
}

type LoadBalancerAttributesTagsObservation struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LoadBalancerAttributesTagsParameters struct {
}

// LoadBalancerAttributesSpec defines the desired state of LoadBalancerAttributes
type LoadBalancerAttributesSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LoadBalancerAttributesParameters `json:"forProvider"`
}

// LoadBalancerAttributesStatus defines the observed state of LoadBalancerAttributes.
type LoadBalancerAttributesStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LoadBalancerAttributesObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// LoadBalancerAttributes is the Schema for the LoadBalancerAttributess API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,upjet-provider-outscale}
type LoadBalancerAttributes struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LoadBalancerAttributesSpec   `json:"spec"`
	Status            LoadBalancerAttributesStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LoadBalancerAttributesList contains a list of LoadBalancerAttributess
type LoadBalancerAttributesList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LoadBalancerAttributes `json:"items"`
}

// Repository type metadata.
var (
	LoadBalancerAttributes_Kind             = "LoadBalancerAttributes"
	LoadBalancerAttributes_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: LoadBalancerAttributes_Kind}.String()
	LoadBalancerAttributes_KindAPIVersion   = LoadBalancerAttributes_Kind + "." + CRDGroupVersion.String()
	LoadBalancerAttributes_GroupVersionKind = CRDGroupVersion.WithKind(LoadBalancerAttributes_Kind)
)

func init() {
	SchemeBuilder.Register(&LoadBalancerAttributes{}, &LoadBalancerAttributesList{})
}
